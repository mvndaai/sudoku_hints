<html>
    <head lang="en">
        <title>Sudoku Hints</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta charset="utf-8"/>
        <script src="https://cdn.jsdelivr.net/gh/golang/go@go1.24.6/lib/wasm/wasm_exec.js"></script>
        <script>
            const go = new Go();
            const loadGo = WebAssembly.instantiateStreaming(fetch("main.wasm"), go.importObject)
        </script>
        <style>
            body, .column {
                background-color: linen;
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                padding: 10px;
                box-sizing: border-box;
                margin: 0;
            }
            .row {
                display: flex;
                flex-direction: row;
                justify-content: center;
                align-items: center;
                flex-wrap: wrap;
                width: 100%;
                max-width: 600px;
            }
            .row button {
                margin: 5px;
            }
            .failure {
                background: rgb(255, 100, 100);
            }
            .success {
                background: rgb(51, 201, 51);
            }
            :popover-open {
                position: absolute;
                inset: unset;
                left: 5px;
                bottom: 5px;
            }
            #sudokuCanvas {
                max-width: calc(100vw - 20px);
                max-height: calc(100vw - 20px);
                width: 450px;
                height: 450px;
                border: 2px solid #333;
                background: white;
                display: block;
            }
        </style>
    </head>
    <body>
        <h1>Sudoku Hints</h1>
        <p>Get hints for solving Sudoku puzzles.</p>

        <canvas id="sudokuCanvas" tabindex="0"></canvas>

        <div class="row" style="margin-top: 20px;">
            <button onclick="removeCandidate()">Remove Candidate</button>
            <button onclick="next()">Next</button>
            <button onclick="solve()">Solve</button>
        </div>

        <div class="row" style="margin: 20px 0;">
            <button id="userInput" popovertarget="manualInputModal">
                ‚å® Input Manually
            </button>
            <dialog id="manualInputModal" popover style="padding: 20px; border: 2px solid #333; border-radius: 8px;">
                <h2>Manual Input</h2>
                <p>Enter your Sudoku puzzle manually:</p>
                <div id="manualInputGrid" style="display: grid; grid-template-columns: repeat(9, 40px); gap: 1px; background: #333; border: 2px solid #333;">
                </div>
                <div style="margin-top: 10px;">
                    <button onclick="document.getElementById('manualInputModal').hidePopover()" style="margin: 5px; padding: 8px 16px;">Cancel</button>
                    <button onclick="loadManualPuzzle()" style="margin: 5px; padding: 8px 16px;">Load Puzzle</button>
                </div>
            </dialog>

            <button id="uploadBtn">
                üì∑ From Image
            </button>

            <button id="requestDosukoBtn">
                üß© New Dosuko
            </button>

            <button id="randomBtn">
                ‚ùì Random
            </button>

            <!--<input type="file" id="imageInput" accept="image/*" capture="environment" style="display: none;">-->
            <input type="file" id="imageInput" accept="image/*;capture=camera" style="display: none;">
        </div>

        <script>
            document.getElementById('uploadBtn').addEventListener('click', () => document.getElementById('imageInput').click());

            // Utility: read a File and return Uint8Array bytes
            async function fileToBytes(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(new Uint8Array(e.target.result));
                    reader.onerror = (e) => reject(e);
                    reader.readAsArrayBuffer(file);
                });
            }
            document.getElementById('imageInput').addEventListener('change', async function(event) {
            const file = event.target.files[0];
            if (file) {
                makeToast(`Processing image: ${file.name}`);
                try {
                    const bytes = await fileToBytes(file);
                    const response = await golang.processOCR(file.name, bytes);
                    makeToast('Image processed successfully!', 'success');
                    loadSudokuPuzzle(JSON.parse(response));

                } catch (error) {
                    makeToast('Error processing image: ' + error.message, 'failure');
                    console.error('Error:', error);
                }
            }
            });
            const canvas = document.getElementById('sudokuCanvas');
            let selectedCell = null;
            let currentPuzzleData = null; // Initialize as null, will be set when examplePuzzle is available
            const ctx = canvas.getContext('2d');
            
            // Make canvas responsive
            function resizeCanvas() {
                const maxSize = Math.min(450, window.innerWidth - 20);
                canvas.width = maxSize;
                canvas.height = maxSize;
                if (currentPuzzleData) {
                    redrawPuzzle();
                } else {
                    drawSudokuGrid();
                }
            }
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            function getCellSize() {
                return canvas.width / 9;
            }

            // Add click event listener to canvas
            canvas.addEventListener('click', function(event) {
                const rect = canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;

                const cellSize = getCellSize();
                const col = Math.floor(x / cellSize);
                const row = Math.floor(y / cellSize);

                if (row >= 0 && row < 9 && col >= 0 && col < 9) {
                    //makeToast(`Clicked cell at row ${row}, col ${col}`);
                    const cell = currentPuzzleData[row][col].cell;
                    if (!cell.isPreFilled && (cell.value === "" || !cell.value)) {
                        selectedCell = { row, col };
                        canvas.focus();

                        // TOOD check if this works
                        // Create a hidden input to trigger mobile keyboard
                        let hiddenInput = document.getElementById('hiddenNumberInput');
                        if (!hiddenInput) {
                            hiddenInput = document.createElement('input');
                            hiddenInput.id = 'hiddenNumberInput';
                            hiddenInput.type = 'number';
                            hiddenInput.inputMode = 'numeric';
                            hiddenInput.pattern = '[1-9]';
                            hiddenInput.min = '1';
                            hiddenInput.max = '9';
                            hiddenInput.style.position = 'absolute';
                            hiddenInput.style.left = '-9999px';
                            hiddenInput.style.width = '1px';
                            hiddenInput.style.height = '1px';
                            document.body.appendChild(hiddenInput);

                            // Handle input from the hidden field
                            hiddenInput.addEventListener('input', function(e) {
                                const value = e.target.value;
                                if (/^[1-9]$/.test(value) && selectedCell) {
                                    const evt = new KeyboardEvent('keydown', { key: value });
                                    canvas.dispatchEvent(evt);
                                    e.target.value = '';
                                }
                            });
                        }

                        // Focus the hidden input to open keyboard
                        hiddenInput.focus();
                    } else {
                        selectedCell = null;
                    }
                    redrawPuzzle();
                }
            });

            // Add keydown event listener
            canvas.addEventListener('keydown', function(event) {
                if (!selectedCell) return;

                const key = event.key;
                if (/^[1-9]$/.test(key)) {
                    const number = parseInt(key);
                    //makeToast(`Input ${number} at row ${selectedCell.row}, col ${selectedCell.col}`);

                    const cell = currentPuzzleData[selectedCell.row][selectedCell.col].cell;
                    if (cell.candidates && cell.candidates.includes(number.toString())) {
                        // Set the cell as solved
                        cell.value = number.toString();
                        const puzzle = golang.setCell(selectedCell.row, selectedCell.col, number.toString());
                        //console.log(puzzle);
                        let parsedPuzzle;
                        try {
                            parsedPuzzle = JSON.parse(puzzle);
                        } catch (error) {
                            makeToast('Error parsing puzzle response: ' + error.message + puzzle, 'failure');
                            console.error('JSON parse error:', error, 'Response:', puzzle);
                            return;
                        }

                        if (parsedPuzzle.solved) {
                            makeToast('Puzzle solved!', 'success');
                        }
                        redrawPuzzle(parsedPuzzle.board);
                    }
                } else if (key === 'Delete' || key === 'Backspace') {
                    const cell = currentPuzzleData[selectedCell.row][selectedCell.col].cell;
                    if (cell.value && cell.value !== "" && !cell.isPreFilled) {
                        // Convert back to unsolved with original candidates
                        cell.value = "";
                        // TODO fix the revert with golang
                        redrawPuzzle();
                    }
                }
            });

            function drawSelectedCell() {
            if (!selectedCell) return;
                const cellSize = getCellSize();
                const x = selectedCell.col * cellSize;
                const y = selectedCell.row * cellSize;

                ctx.fillStyle = 'rgba(0, 122, 204, 0.3)';
                ctx.fillRect(x + 1, y + 1, cellSize - 2, cellSize - 2);

                ctx.strokeStyle = '#007acc';
                ctx.lineWidth = 3;
                ctx.strokeRect(x + 1, y + 1, cellSize - 2, cellSize - 2);
            }
            function redrawPuzzle(puzzle) {
                if (puzzle) {
                    loadSudokuPuzzle(puzzle);
                    drawSelectedCell();
                    return
                }

                if (currentPuzzleData) {
                    //console.log("redraw current", currentPuzzleData)
                    let golangPuzzle = JSON.parse(golang.currentGame()).board;
                    //console.log("redraw golang", golangPuzzle)

                    //loadSudokuPuzzle(currentPuzzleData);
                    loadSudokuPuzzle(golangPuzzle);
                    drawSelectedCell();
                }
            }

            function drawSudokuGrid() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                const cellSize = getCellSize();
                // Draw grid lines
                ctx.strokeStyle = '#000';
                for (let i = 0; i <= 9; i++) {
                ctx.lineWidth = (i % 3 === 0) ? 3 : 1;
                ctx.beginPath();
                // Vertical lines
                ctx.moveTo(i * cellSize, 0);
                ctx.lineTo(i * cellSize, 9 * cellSize);
                // Horizontal lines
                ctx.moveTo(0, i * cellSize);
                ctx.lineTo(9 * cellSize, i * cellSize);
                ctx.stroke();
                }
            }

            function drawCellBackground(row, col, isPreFilled) {
                if (isPreFilled) {
                    const cellSize = getCellSize();
                    const x = col * cellSize;
                    const y = row * cellSize;
                    ctx.fillStyle = '#f0f0f0';
                    ctx.fillRect(x + 1, y + 1, cellSize - 2, cellSize - 2);
                }
            }

            function drawNumber(row, col, number, isLastFilled) {
                const cellSize = getCellSize();
                const x = col * cellSize + cellSize / 2;
                const y = row * cellSize + cellSize / 2;

                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const fontSize = Math.floor(cellSize * 0.48);
                ctx.font = `${fontSize}px Arial`;
                ctx.fillStyle = isLastFilled ? '#008000' : '#000';
                ctx.fillText(number, x, y);
            }

            function drawCandidates(row, col, candidates, recentCandidates) {
                const cellSize = getCellSize();
                const cellX = col * cellSize;
                const cellY = row * cellSize;

                // Map candidates and recentCandidates to objects with type, then combine and sort
                const normalCandidates = (candidates || []).map(c => ({ value: c, isRecent: false }));
                const recentCandidatesTyped = (recentCandidates || []).map(c => ({ value: c, isRecent: true }));
                const combinedCandidates = [...normalCandidates, ...recentCandidatesTyped];
                    //.sort((a, b) => a.value - b.value);

                const fontSize = Math.floor(cellSize * 0.2);
                ctx.font = `${fontSize}px Arial`;
                ctx.textAlign = 'center';

                // Check if there's only one candidate
                const isSingleCandidate = candidates.length === 1;

                // Draw all candidates
                const spacing = cellSize / 3;
                const offset = cellSize * 0.16;
                for (let i = 0; i < combinedCandidates.length && i < 9; i++) {
                    const candidate = combinedCandidates[i];
                    const candidateRow = Math.floor(i / 3);
                    const candidateCol = i % 3;
                    const x = cellX + offset + candidateCol * spacing;
                    const y = cellY + offset + fontSize * 0.35 + candidateRow * spacing;
                    
                    // Set color based on type
                    if (candidate.isRecent) {
                        ctx.fillStyle = '#b20000'; // dark red for recent
                    } else {
                        ctx.fillStyle = isSingleCandidate ? '#008000' : '#999'; // green if single, gray otherwise
                    }
                    
                    ctx.fillText(candidate.value, x, y);
                }
            }

            function loadSudokuPuzzle(puzzleData) {
                //console.log('Loading puzzle data:', puzzleData);

                if (typeof puzzleData === 'string') {
                    puzzleData = JSON.parse(puzzleData);
                    if (typeof puzzleData !== 'object') {
                        makeToast('Error: Invalid puzzle data format', 'failure');
                        console.error('Puzzle data is a string, expected object:', puzzleData);
                        return;
                    }
                }
                //console.log("Puzzle data after parsing:", puzzleData);
                if (puzzleData.board) {
                    puzzleData = puzzleData.board;
                }
                //console.log("Puzzle data after extracting board:", puzzleData);
                currentPuzzleData = puzzleData;
                // TODO call the golang code to get the hints.
                drawSudokuGrid();

                for (let rowIndex = 0; rowIndex < puzzleData.length; rowIndex++) {
                    for (let colIndex = 0; colIndex < puzzleData[rowIndex].length; colIndex++) {
                        const cellWrapper = puzzleData[rowIndex][colIndex];
                        const cell = cellWrapper.cell;

                        // Draw cell background first
                        drawCellBackground(rowIndex, colIndex, cell.isPreFilled);

                        if (cell.value && cell.value !== "") {
                            drawNumber(rowIndex, colIndex, parseInt(cell.value), cell.isLastFilled);
                        } else if (cell.candidates) {
                            drawCandidates(
                                rowIndex,
                                colIndex,
                                cell.candidates.map(c => parseInt(c)),
                                cell.recentCandidates ? cell.recentCandidates.map(c => parseInt(c)) : []
                            );
                        }
                    }
                }
                //console.log("Finished drawing puzzle");
            }

            // Initialize the grid
            drawSudokuGrid();

            const btns = document.querySelectorAll('button');
            btns.forEach(btn => btn.disabled = true);
            loadGo.then((result) => {
                go.run(result.instance);

                // Initialize the grid
                drawSudokuGrid();

                const random = JSON.parse(golang.random());
                //console.log(JSON.stringify(random));

                loadSudokuPuzzle(random);
                btns.forEach(btn => btn.disabled = false);
            });

            window.next = () => {
                let next = golang.next(JSON.stringify(currentPuzzleData));
                loadSudokuPuzzle(next);
            }

            window.removeCandidate = () => {
                const result = golang.removeCandidate();
                if (typeof result === 'string' && (result.startsWith('Error') || result.startsWith('No'))) {
                    makeToast(result, 'failure');
                    return;
                }
                try {
                    const parsed = JSON.parse(result);
                    if (parsed.game && parsed.change) {
                        loadSudokuPuzzle(parsed.game);
                        makeToast(parsed.change);
                    }
                } catch (e) {
                    // Fallback for backwards compatibility
                    loadSudokuPuzzle(result);
                }
            }

            window.solve = () => {
                let solve = golang.next(JSON.stringify(currentPuzzleData), JSON.stringify({autoSolve: true}));
                loadSudokuPuzzle(solve);
            }

            document.querySelector("#requestDosukoBtn").addEventListener("click", async () => {
                //console.log("in requestDosukoBtn click event");
                let puzzle = JSON.parse(await golang.requestDosuko());
                makeToast(`Loaded Dosuko puzzle (Difficulty: ${puzzle.difficulty})`, "success");
                loadSudokuPuzzle(puzzle.board);
            });

            document.querySelector("#randomBtn").addEventListener("click", async () => {
                const puzzle = JSON.parse(golang.random());
                loadSudokuPuzzle(puzzle);

                if (puzzle.difficulty){
                    makeToast(`Loaded random puzzle (Difficulty: ${puzzle.difficulty})`, "success");
                } else {
                    makeToast(`Loaded random puzzle`, "success");
                }
            });

            // https://mdn.github.io/dom-examples/popover-api/toast-popovers/
            function makeToast(msg, type) {
                // Create an element and make it into a popover
                const popover = document.createElement("article");
                popover.popover = "manual";
                popover.classList.add("toast");
                popover.classList.add("newest");
                popover.classList.add(type);

                // Give the toast its text content, and add it to the DOM
                popover.textContent = msg;
                document.body.appendChild(popover);

                // Show the popover
                popover.showPopover();

                // Remove the toast again after 4 seconds
                setTimeout(() => {
                    popover.hidePopover();
                    popover.remove();
                }, 4000);

                // When a new toast appears, run the movetoastsUp() function
                popover.addEventListener("toggle", (event) => {
                    if (event.newState === "open") {
                        moveToastsUp();
                    }
                });
            }
            function moveToastsUp() {
                const toasts = document.querySelectorAll(".toast");
                toasts.forEach((toast) => {
                    // If the toast is the one that has just appeared, we don't want it to move up.
                    if (toast.classList.contains("newest")) {
                        toast.style.bottom = `5px`;
                        toast.classList.remove("newest");
                    } else {
                        // Move up all the other toasts by 50px to make way for the new one
                        const prevValue = toast.style.bottom.replace("px", "");
                        const newValue = parseInt(prevValue) + 50;
                        toast.style.bottom = `${newValue}px`;
                    }
                });
            }

            function fillManualInputGrid() {
                for (let i = 0; i < 81; i++) {
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.inputMode = 'numeric';
                    input.maxLength = 1;
                    input.style.cssText = 'width: 40px; height: 40px; text-align: center; font-size: 18px; border: none; background: white;';
                    input.dataset.index = i;

                    // Add thicker borders for 3x3 boxes
                    const row = Math.floor(i / 9);
                    const col = i % 9;
                    if (col % 3 === 0 && col !== 0) input.style.borderLeft = '2px solid #333';
                    if (row % 3 === 0 && row !== 0) input.style.borderTop = '2px solid #333';

                    input.addEventListener('input', (e) => {
                        const value = e.target.value;
                        // Only allow digits 0-9
                        if (!/^[0-9]?$/.test(value)) {
                            e.target.value = '';
                            return;
                        }
                        if (!value) return;
                        const nextIndex = parseInt(e.target.dataset.index) + 1;
                        const nextInput = document.querySelector(`input[data-index="${nextIndex}"]`);
                        nextInput?.focus();
                    });

                    input.addEventListener('keydown', (e) => {
                        const currentIndex = parseInt(e.target.dataset.index);
                        let targetIndex;
                        if (e.key === 'ArrowRight') {
                            e.preventDefault();
                            targetIndex = currentIndex + 1;
                            if (targetIndex < 81) {
                                document.querySelector(`input[data-index="${targetIndex}"]`)?.focus();
                            }
                        } else if (e.key === 'ArrowLeft') {
                            e.preventDefault();
                            targetIndex = currentIndex - 1;
                            if (targetIndex >= 0) {
                                document.querySelector(`input[data-index="${targetIndex}"]`)?.focus();
                            }
                        } else if (e.key === 'ArrowDown') {
                            e.preventDefault();
                            targetIndex = currentIndex + 9;
                            if (targetIndex < 81) {
                                document.querySelector(`input[data-index="${targetIndex}"]`)?.focus();
                            }
                        } else if (e.key === 'ArrowUp') {
                            e.preventDefault();
                            targetIndex = currentIndex - 9;
                            if (targetIndex >= 0) {
                                document.querySelector(`input[data-index="${targetIndex}"]`)?.focus();
                            }
                        } else if (e.key === 'Backspace' && !e.target.value) {
                            const prevIndex = currentIndex - 1;
                            if (prevIndex >= 0) {
                                document.querySelector(`input[data-index="${prevIndex}"]`)?.focus();
                            }
                        }
                    });

                    document.getElementById('manualInputGrid').appendChild(input);
                }
            }

            function loadManualPuzzle() {
                    const inputs = document.querySelectorAll('#manualInputGrid input');

                    // Build 2D array for the Go backend
                    const board = [];
                    for (let i = 0; i < 9; i++) {
                        const row = [];
                        for (let j = 0; j < 9; j++) {
                            const value = inputs[i * 9 + j].value;
                            row.push(value ? parseInt(value) : 0);
                        }
                        board.push(row);
                    }
                    // Send to Go backend to initialize the game
                    console.log("Loading manual puzzle:", board, JSON.stringify(board));
                    const response = golang.loadBoard(JSON.stringify(board));

                    try {
                        loadSudokuPuzzle(JSON.parse(response));
                    } catch (error) {
                        makeToast('Error loading board: ' + error.message, 'failure');
                        console.error('Error loading board:', error, 'Response:', response);
                        return;
                    }
                    document.getElementById('manualInputModal').hidePopover();
                    makeToast('Puzzle loaded successfully!', 'success');
                }


            fillManualInputGrid();
        </script>

        <style>#forkongithub a{background:#000;color:#fff;text-decoration:none;font-family:arial,sans-serif;text-align:center;font-weight:bold;padding:5px 40px;font-size:1rem;line-height:2rem;position:relative;transition:0.5s;}#forkongithub a:hover{background:#c11;color:#fff;}#forkongithub a::before,#forkongithub a::after{content:"";width:100%;display:block;position:absolute;top:1px;left:0;height:1px;background:#fff;}#forkongithub a::after{bottom:1px;top:auto;}@media screen and (min-width:1000px){#forkongithub{position:fixed;display:block;top:0;right:0;width:200px;overflow:hidden;height:200px;z-index:9999;}#forkongithub a{width:200px;position:absolute;top:60px;right:-60px;transform:rotate(45deg);-webkit-transform:rotate(45deg);-ms-transform:rotate(45deg);-moz-transform:rotate(45deg);-o-transform:rotate(45deg);box-shadow:4px 4px 10px rgba(0,0,0,0.8);}}</style>
        <span id="forkongithub"><a href="https://github.com/mvndaai/sudoku_hints">Fork me on GitHub</a></span>
    </body>
</html>
