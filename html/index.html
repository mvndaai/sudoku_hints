<html>
    <head lang="en">
        <title>Sudoku Hints</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta charset="utf-8"/>
        <script src="https://cdn.jsdelivr.net/gh/golang/go@go1.24.6/lib/wasm/wasm_exec.js"></script>
        <script>
            const go = new Go();
            const loadGo = WebAssembly.instantiateStreaming(fetch("main.wasm"), go.importObject)
        </script>
        <style>
            body, .column {
                background-color: linen;
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
            }
            .row {
                display: flex;
                flex-direction: row;
                justify-content: center;
                align-items: center;
            }
            .failure {
                background: rgb(255, 100, 100);
            }
            .success {
                background: rgb(51, 201, 51);
            }
            :popover-open {
                position: absolute;
                inset: unset;
                left: 5px;
                bottom: 5px;
            }
        </style>
    </head>
    <body>
        <h1>Sudoku Hints</h1>
        <p>Get hints for solving Sudoku puzzles.</p>

        <canvas id="sudokuCanvas" width="450" height="450" style="border: 2px solid #333; background: white;" tabindex="0"></canvas>

        <div class="row" style="margin-top: 20px;">
            <button id="uploadBtn" style="margin: 10px; padding: 10px 20px; font-size: 16px;">
            ðŸ“· Upload Image or Take Photo
            </button>

            <button onclick="next()" style="margin: 10px; padding: 10px 20px; font-size: 16px;">Next</button>
            <!--<input type="file" id="imageInput" accept="image/*" capture="environment" style="display: none;">-->
            <input type="file" id="imageInput" accept="image/*" style="display: none;">
        </div>

        <script>
            document.getElementById('uploadBtn').addEventListener('click', () => document.getElementById('imageInput').click());

            // Utility: read a File and return Uint8Array bytes
            async function fileToBytes(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(new Uint8Array(e.target.result));
                    reader.onerror = (e) => reject(e);
                    reader.readAsArrayBuffer(file);
                });
            }
            document.getElementById('imageInput').addEventListener('change', async function(event) {
            const file = event.target.files[0];
            if (file) {
                makeToast(`Processing image: ${file.name}`);
                try {
                    const bytes = await fileToBytes(file);
                    const response = await golang.processOCR(file.name, bytes);
                    makeToast('Image processed successfully!', 'success');
                    loadSudokuPuzzle(JSON.parse(response));

                } catch (error) {
                    makeToast('Error processing image: ' + error.message, 'failure');
                    console.error('Error:', error);
                }
            }
            });
            const canvas = document.getElementById('sudokuCanvas');
            let selectedCell = null;
            let currentPuzzleData = null; // Initialize as null, will be set when examplePuzzle is available

            // Add click event listener to canvas
            canvas.addEventListener('click', function(event) {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            const col = Math.floor(x / cellSize);
            const row = Math.floor(y / cellSize);

            if (row >= 0 && row < 9 && col >= 0 && col < 9) {
                //makeToast(`Clicked cell at row ${row}, col ${col}`);
                const cell = currentPuzzleData[row][col].cell;
                if (!cell.isPreFilled && (cell.value === "" || !cell.value)) {
                    selectedCell = { row, col };
                    canvas.focus();
                } else {
                    selectedCell = null;
                }
                redrawPuzzle();
            }
            });

            // Add keydown event listener
            canvas.addEventListener('keydown', function(event) {
                if (!selectedCell) return;

                const key = event.key;
                if (/^[1-9]$/.test(key)) {
                    const number = parseInt(key);
                    //makeToast(`Input ${number} at row ${selectedCell.row}, col ${selectedCell.col}`);

                    const cell = currentPuzzleData[selectedCell.row][selectedCell.col].cell;
                    if (cell.candidates && cell.candidates.includes(number.toString())) {
                        // Set the cell as solved
                        cell.value = number.toString();
                        cell.candidates = null;
                        redrawPuzzle();
                    }
                } else if (key === 'Delete' || key === 'Backspace') {
                    const cell = currentPuzzleData[selectedCell.row][selectedCell.col].cell;
                    if (cell.value && cell.value !== "" && !cell.isPreFilled) {
                        // Convert back to unsolved with original candidates
                        cell.value = "";
                        cell.candidates = ["1","2","3","4","5","6","7","8","9"];
                    }
                }
            });

            function drawSelectedCell() {
            if (!selectedCell) return;
                const x = selectedCell.col * cellSize;
                const y = selectedCell.row * cellSize;

                ctx.fillStyle = 'rgba(0, 122, 204, 0.3)';
                ctx.fillRect(x + 1, y + 1, cellSize - 2, cellSize - 2);

                ctx.strokeStyle = '#007acc';
                ctx.lineWidth = 3;
                ctx.strokeRect(x + 1, y + 1, cellSize - 2, cellSize - 2);
            }
            function redrawPuzzle() {
                if (currentPuzzleData) {
                    loadSudokuPuzzle(currentPuzzleData);
                    drawSelectedCell();
                }
            }

            const ctx = canvas.getContext('2d');
            const cellSize = 50;
            function drawSudokuGrid() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Draw grid lines
                ctx.strokeStyle = '#000';
                for (let i = 0; i <= 9; i++) {
                ctx.lineWidth = (i % 3 === 0) ? 3 : 1;
                ctx.beginPath();
                // Vertical lines
                ctx.moveTo(i * cellSize, 0);
                ctx.lineTo(i * cellSize, 9 * cellSize);
                // Horizontal lines
                ctx.moveTo(0, i * cellSize);
                ctx.lineTo(9 * cellSize, i * cellSize);
                ctx.stroke();
                }
            }

            function drawCellBackground(row, col, isPreFilled) {
                if (isPreFilled) {
                    const x = col * cellSize;
                    const y = row * cellSize;
                    ctx.fillStyle = '#f0f0f0';
                    ctx.fillRect(x + 1, y + 1, cellSize - 2, cellSize - 2);
                }
            }

            function drawNumber(row, col, number) {
                const x = col * cellSize + cellSize / 2;
                const y = row * cellSize + cellSize / 2;

                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.font = '24px Arial';
                ctx.fillStyle = '#000';
                ctx.fillText(number, x, y);
            }

            function drawCandidates(row, col, candidates) {
                const cellX = col * cellSize;
                const cellY = row * cellSize;

                ctx.font = '10px Arial';
                ctx.fillStyle = '#999';
                ctx.textAlign = 'center';

                for (let i = 0; i < candidates.length && i < 9; i++) {
                    const candidateRow = Math.floor(i / 3);
                    const candidateCol = i % 3;
                    const x = cellX + 8 + candidateCol * 11;
                    const y = cellY + 12 + candidateRow * 11;
                    ctx.fillText(candidates[i], x, y);
                }
            }

            function loadSudokuPuzzle(puzzleData) {
                console.log('Loading puzzle data:', puzzleData);
                currentPuzzleData = puzzleData;
            // TODO call the golang code to get the hints.
                drawSudokuGrid();

                for (let rowIndex = 0; rowIndex < puzzleData.length; rowIndex++) {
                    for (let colIndex = 0; colIndex < puzzleData[rowIndex].length; colIndex++) {
                        const cellWrapper = puzzleData[rowIndex][colIndex];
                        const cell = cellWrapper.cell;

                        // Draw cell background first
                        drawCellBackground(rowIndex, colIndex, cell.isPreFilled);

                        if (cell.value && cell.value !== "") {
                            drawNumber(rowIndex, colIndex, parseInt(cell.value));
                        } else if (cell.candidates) {
                            drawCandidates(rowIndex, colIndex, cell.candidates.map(c => parseInt(c)));
                        }
                    }
                }
            }

            // Initialize the grid
            drawSudokuGrid();

            const btns = document.querySelectorAll('button');
            btns.forEach(btn => btn.disabled = true);
            loadGo.then((result) => {
                go.run(result.instance);

                // Initialize the grid
                drawSudokuGrid();

                const random = JSON.parse(golang.random());
                //console.log(JSON.stringify(random));

                loadSudokuPuzzle(random);
                btns.forEach(btn => btn.disabled = false);
            });

            window.next = () => {
                let next = golang.next(JSON.stringify(currentPuzzleData));
                loadSudokuPuzzle(JSON.parse(next));
            }

            // https://mdn.github.io/dom-examples/popover-api/toast-popovers/
            function makeToast(msg, type) {
                // Create an element and make it into a popover
                const popover = document.createElement("article");
                popover.popover = "manual";
                popover.classList.add("toast");
                popover.classList.add("newest");
                popover.classList.add(type);

                // Give the toast its text content, and add it to the DOM
                popover.textContent = msg;
                document.body.appendChild(popover);

                // Show the popover
                popover.showPopover();

                // Remove the toast again after 4 seconds
                setTimeout(() => {
                    popover.hidePopover();
                    popover.remove();
                }, 4000);

                // When a new toast appears, run the movetoastsUp() function
                popover.addEventListener("toggle", (event) => {
                    if (event.newState === "open") {
                        moveToastsUp();
                    }
                });
            }
            function moveToastsUp() {
                const toasts = document.querySelectorAll(".toast");
                toasts.forEach((toast) => {
                    // If the toast is the one that has just appeared, we don't want it to move up.
                    if (toast.classList.contains("newest")) {
                        toast.style.bottom = `5px`;
                        toast.classList.remove("newest");
                    } else {
                        // Move up all the other toasts by 50px to make way for the new one
                        const prevValue = toast.style.bottom.replace("px", "");
                        const newValue = parseInt(prevValue) + 50;
                        toast.style.bottom = `${newValue}px`;
                    }
                });
            }
        </script>

        <style>#forkongithub a{background:#000;color:#fff;text-decoration:none;font-family:arial,sans-serif;text-align:center;font-weight:bold;padding:5px 40px;font-size:1rem;line-height:2rem;position:relative;transition:0.5s;}#forkongithub a:hover{background:#c11;color:#fff;}#forkongithub a::before,#forkongithub a::after{content:"";width:100%;display:block;position:absolute;top:1px;left:0;height:1px;background:#fff;}#forkongithub a::after{bottom:1px;top:auto;}@media screen and (min-width:1000px){#forkongithub{position:fixed;display:block;top:0;right:0;width:200px;overflow:hidden;height:200px;z-index:9999;}#forkongithub a{width:200px;position:absolute;top:60px;right:-60px;transform:rotate(45deg);-webkit-transform:rotate(45deg);-ms-transform:rotate(45deg);-moz-transform:rotate(45deg);-o-transform:rotate(45deg);box-shadow:4px 4px 10px rgba(0,0,0,0.8);}}</style>
        <span id="forkongithub"><a href="https://github.com/mvndaai/sudoku_hints">Fork me on GitHub</a></span>
    </body>
</html>
